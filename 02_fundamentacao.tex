\chapter{Fundamentação Teórica}
\label{c_fundamentacao_teorica}

Este capítulo discute os principais temas de interesse desta pesquisa, iniciando pelo sujeito principal: a criança. As bases teóricas são as teorias do Construtivismo e do Construcionismo, e os autores são Jean Piaget, Seymour Papert e Jerome Bruner. A \autoref{fundamentacao_pc} apresenta a definição de \ac{PC} que esta pesquisa segue. Depois o texto apresenta ferramentas voltadas ao aprendizado de algoritmos por crianças, como os brinquedos programáveis.

\section{A criança}
\label{fundamentacao_crianca}
No Brasil, o Estatuto da Criança e do Adolescente considera como criança a pessoa de até 12 anos incompletos \cite{brasil_lei_1990}, porém \citeonline{markopoulos_evaluating_2008} afirma que a duração da infância é relativa a influências culturais, localização e base familiar. O desenvolvimento cognitivo da criança desde o nascimento até a idade adulta foi um dos temas de pesquisa de Piaget, que posteriormente influenciou as pesquisas de Seymour Papert, criador do ambiente Logo.

Compreender como as crianças aprendem é fundamental para projetar ferramentas educacionais efetivas.  Essas ferramentas promovem experiências interativas que permitem ao usuário aprender algo. Para \citeonline{rogers_design_2013}, projetar experiências interativas passa por entender os usuários nos contextos em que vivem, trabalham e também aprendem. Para isso é crucial a observar o indivíduo em seu contexto, para revelar opiniões incorretas, por parte dos designers, sobre o que um grupo deseja ou realmente necessita. Quando o público-alvo do produto interativo é são crianças, é ainda mais difícil para designers, adultos, preverem o que pode ser adequado e simples de usar.

Para abordar a temática do público-alvo desta pesquisa e como ele aprende, esta seção apresenta teorias de aprendizado de Jean Piaget, Jerome Bruner e Seymour Papert. Esses autores buscaram compreender como o conhecimento se constrói na mente da criança, e como materiais externos podem auxiliá-la a aprender melhor. \citeonline{gray_learning_2015} apresenta uma visão completa de teorias de aprendizagem, mas os autores aqui apresentados se justificam pela influência que tiveram no campo das tecnologias educacionais para crianças.

\subsection{Piaget e o Desenvolvimento Cognitivo}
Piaget estudou o desenvolvimento cognitivo da criança e propôs a teoria denominada Epistemologia Genética. Essa teoria une as correntes filosóficas do apriorismo e do empirismo. Enquanto o apriorismo preconiza que todo conhecimento é inato, ou seja, existe no ser humano desde o nascimento, o empirismo defende que o aprendizado e o conhecimento surgem das interações do sujeito com seu meio. Piaget concorda com o empirismo ao afirmar que o conhecimento surge das experiências e também concorda com o apriorismo quando diz que o aprendizado depende de estruturas mentais capazes de assimilar essas experiências.

A partir disso, Piaget descreveu o aprendizado como um processo de assimilação e acomodação. A criança nasce com poucas estruturas mentais (esquemas), e ao receber estímulos motores, conceituais ou perceptuais, tenta classificá-los e assimilá-los de acordo com aquilo que já conhece. Por exemplo, ao ver um cachorro pela primeira vez a criança pode assimilá-lo como sendo outro animal semelhante para o qual já tenha um esquema criado. Ao ser corrigida por um adulto, porém, um novo conceito surge e precisa ser acomodado, criando assim um novo esquema.

Além de descrever o processo de aprendizado, o pesquisador descreve estágios de desenvolvimento cognitivo. Cada estágio se caracteriza pelo modo como a criança realiza determinadas operações mentais. A realização de uma “operação” significa executar uma ação mental com reversão e conservação. Um exemplo conservação é observar que um líquido transvasado de um recipiente maior para outros dois recipientes menores “conserva” sua quantidade total. No mesmo exemplo, o líquido pode ser “revertido” ao recipiente inicial sem haver mudança de volume. Piaget demonstrou que crianças não conseguem perceber essa relação e sugeriu que isso se devia à ausência das estruturas mentais necessárias para tal. Neste sentido, o pesquisador observou as operações mentais que crianças conseguiam executar em cada idade e com isso organizou o desenvolvimento cognitivo em quatro estágios:

\begin{description}
\item[Sensório motor] é o primeiro estágio. Inicia no nascimento e vai até os 18 meses \cite{piaget_development_1964}. Nesta etapa não há conservação ou reversão: quando um objeto some do campo de visão da criança ele deixa de existir para ela. \citeonline{montessori_o_2019} indica não mudar frequentemente o ambiente da criança, para ela poder identificar a permanência dos objetos.

\item[Pré-operacional] é o estágio que inicia aos 18 meses e vai até os 6 ou 7 anos. Ainda não há estruturas que suportam operações mentais, mas há o aparecimento da linguagem e dos símbolos, o que possibilita o pensar.

\item[Operatório-concreto] é o estágio onde se iniciam as operações. Ele é denominado “concreto”, pois as operações dependem de objetos físicos, ou seja, a operação mental precisa estar ligada a uma ação física. Neste período a criança consegue classificar, ordenar objetos e contar.

\item[Operatório-formal] é o último estágio, e vai dos 12 anos até o final da vida. Há raciocínio sobre hipóteses abstratas, impossíveis até de serem concretizadas fisicamente. Há suporte para captar informações de fontes variadas e obter conclusões, o que é mais complexo que o raciocínio ligado a ordenação e classificação \cite{piaget_development_1964}.

\end{description}

Percebe-se, a partir da descrição do estágio operatório-concreto, a relação de objetos concretos na realização de operações mentais por crianças entre 7 e 12 anos. Segundo Hourcade (2015), a pesquisa de Piaget sobre como a criança aprende afetou fortemente os campos da IHC. A importância de materiais concretos até hoje é observável em ambientes educacionais infantis. No campo das interfaces de programação pode ser observado nas interfaces tangíveis, que permitem à criança programar utilizando objetos físicos.

\subsection{Jerome Bruner: Construtivismo no Ensino}
\label{sub_jerome_bruner}
Assim como Piaget, Bruner foi um psicólogo construtivista e apoiava a ideia de que o conhecimento é construído pelo indivíduo ao viver diferentes experiências. Porém, enquanto Piaget se concentrou na aprendizagem, Bruner estudou no ensino e mais especificamente em como melhorá-lo. Neste sentido, Bruner destaca três aspectos para melhorar o ensino: representação do aprendizado, currículo em espiral e aprendizagem por descobertas.

A representação do aprendizado seria a forma de adquirir e internalizar o conhecimento, e também ocorre em estágios. Há três modos de representação: enativa, icônica e simbólica. A primeira aconteceria com experiências concretas, “mão na massa”, com estímulos sensoriais tangíveis. Um exemplo seria a criança dividir uma laranja em duas partes. Na segunda fase — representação icônica — o aprendiz associa as experiências sensoriais anteriores com imagens e figuras semelhantes com aquilo que representam. A figura de uma laranja dividida em partes é associada com a experiência concreta de ver uma laranja real partida em pedaços.

Esse espectro de representação do concreto/sensorial para o abstrato/formal pode traçar um paralelo com as interfaces de programação. A criança precisa ter contato físico, enativo com algo. Esse contato facilita a compreensão do algoritmo criados com ícones representando objetos reais, como usados em programação em blocos virtuais \cite{flannery_designing_2013}. Por fim, o contato com programas criados com ícones permite entender a lógica de programação e alcançar o uso de linguagens textuais.

O segundo aspecto que Bruner defende é o currículo em espiral. A ideia é que cada atividade de ensino deve repetir fundamentos lecionados em uma etapa anterior e adicionar novas camadas de complexidade. À medida que a complexidade aumenta, o aluno tem necessidade de um auxílio para entender determinados conceitos. Aí entra o papel de um tutor com a informação a ser transmitida, proporcionando o que Bruner denomina \textit{scaffolding}. No \textit{scaffolding} o tutor auxilia o estudante no aprendizado inicial de um conteúdo \cite{valkenburg_joining_2010} e remove a assistência à medida que o aprendiz adquire autonomia. Para isso o tutor \textit{scaffolding} avalia o que o estudante já sabe e trabalha somente as suas dificuldades, garantindo que ele faça a maior parte do trabalho de forma independente \cite{valkenburg_joining_2010}.

Projetar ferramentas que incentivem o \textit{scaffolding} entre adultos e crianças é uma preocupação do campo de design de interação para crianças. \citeonline{plowman_interactivity_2004} observam que a presença de um elemento tangível pode aumentar o número de vezes em que adultos auxiliam crianças. \citeonline{horn_tangible_2012} afirmam que as interfaces tangíveis combinadas com as interfaces gráficas tem o potencial de fornecer \textit{scaffolding} à medida que os estudantes podem transitar de um sistema tangível para sistemas gráficos com recursos e complexidades aumentados. Já \citeonline{catlin_edurobot_2018} comenta o mesmo sobre a robótica educacional:

\begin{citacao}
Robots allow teachers to create environments which reflect Bruner’s Spiral Curriculum [...]. Young children start with [a robot] where all they do is put symbols in the right order, but as their experience and interest grows they can end up coding in professional programming languages. Several robots provide rich educational environments by offering different ways for students to program them \cite{catlin_edurobot_2018}.
\end{citacao}

Por fim, Bruner defende o aprendizado por descobertas. Segundo ele, o aprendiz deve estar motivado pela curiosidade. Representar conceitos adequadamente e auxiliar o aprendiz em suas dificuldades são formas de contribuir para que sua curiosidade se transforme em conhecimento.

\subsection{Papert e o Construcionismo}

Seymour Papert também estudou o desenvolvimento infantil. Enquanto Piaget e Bruner são construtivistas, Papert criou a teoria denominada Construcionismo. Ela tem base no construtivismo de Piaget, com quem Papert trabalhou, e ambas as teorias compartilham a ideia de “construir estruturas de conhecimento” \cite{papert_situating_1991}. A diferença é que Construtivismo se concentra em como as estruturas são construídas na mente do aprendiz, e o Construcionismo foca em como materiais externos podem auxiliar na construção dessas estruturas de conhecimento \cite{bers_blocks_2008}.

O foco nos materiais e ferramentas decorre da crença de que objetos bem projetados possibilitam criar projetos significativos do ponto de vista epistemológico \cite{bers_blocks_2008}. O material deve ter uma finalidade aberta, permitindo criar em vez de apenas usar algo pronto. Exemplos desses materiais são blocos de encaixar, o computador e a robótica. Eles permitem combinar diferentes partes, blocos e estruturas para testar hipóteses, errar e avaliar possibilidades. Essa versatilidade possibilita ao aprendiz criar artefatos do seu interesse, o que aumenta a motivação e a curiosidade assim como a aprendizagem por descobertas proposta por Bruner. \citeonline{papert_teaching_1972} comentava:

\begin{citacao}
Eu acredito com Dewey, Montessori e Piaget que as crianças aprendem fazendo e pensando sobre o que fazem. Portanto, os ingredientes fundamentais da inovação educacional devem ser coisas melhores para fazer e maneiras melhores de pensar sobre si mesmo fazendo essas coisas \cite[p.3, tradução nossa]{papert_teaching_1972}.
\end{citacao}

A liberdade da programação está em criar blocos de código e combiná-los de infinitas maneiras e gerar infinitos resultados. Percebendo essa harmonia com o Construcionismo, Papert e seu grupo de pesquisa desenvolveram a linguagem LOGO, a primeira linguagem de programação criada para e por crianças \cite{solomon_history_2020}. A linguagem LOGO é conhecida como a “linguagem da tartaruga” ao permitir programar um agente para se mover, girar e desenhar. Essa tartaruga pode ser digital, na tela de um computador; ou física, na forma de brinquedos programáveis.

Desde o desenvolvimento do LOGO, pesquisas têm se inspirado nos fundamentos construcionistas para criar ferramentas adaptadas para crianças. Exemplos são ambientes de programação em blocos como o Scratch e o ScratchJr \cite{flannery_designing_2013}, e diversos brinquedos programáveis (ver \autoref{brinquedos_programaveis}). Os ambientes de programação em blocos permitem encaixar blocos de código evitando erros de sintaxe comuns na programação da digitação em teclado, como no caso do LOGO. Já os BPs permitem infinitos programas ainda que com número reduzido de comandos disponíveis. Essas ferramentas carregam os princípios construcionistas de serem fáceis de começar, mas infinitas nas possibilidades de criar, testar hipóteses, e compartilhar criações significativas.

\citeonline{bers_blocks_2008} adaptou os princípios construcionistas para o contexto da Educação Infantil, dos quais dois fundamentam esse trabalho. O primeiro deles é \textit{“Usar objetos concretos para construir e explorar o mundo"}. O estágio operatório concreto proposto por Piaget menciona a necessidade que crianças têm de utilizar objetos concretos para realizar operações mentais. Crianças precisam se engajar em atividades com objetos reais, com manipulação de brinquedos que as façam pensar. O modo de interação mais proeminente neste sentido são as interfaces tangíveis. O segundo princípio é \textit{"Engajar em autorreflexão como parte do processo"}. Depurar algoritmos representa essa reflexão, ou seja, o momento que a criança pensa sobre aquilo que criou. Ao encontrar um erro, ocorre então o processo de acomodação, ou seja, o resultado não se“encaixa” nos esquemas existentes na mente da criança e precisa ser acomodado. A criança pode então alterar o algoritmo, e ao executar novamente, perceber se o resultado pode ser assimilado pelo esquema mental recém-criado, confirmando ou refutando-o.
    
\begin{comment}
    \citeonline{bers_blocks_2008} lista quatro princípios do Construcionismo que se adaptam à Educação Infantil.
    \item Aprender criando projetos significativos e pessoais para compartilhar com a comunidade;
    \item Usar objetos concretos para construir e explorar o mundo;
    \item Identificar ideias poderosas do domínio de estudo;
\end{comment}

As teorias apresentadas nesta seção representam apenas um recorte da teoria existente, e buscou focar em aspectos ligados ao tema de ferramentas educacionais. O Construcionismo é uma filosofia centrada em apoiar a liberdade do aprendiz, e para isso propõe o uso de ferramentas poderosas que o auxiliem a criar e a pensar sobre essas criações. A programação é uma dessas ferramentas e permite o exercício da criatividade e autonomia por parte do estudante. A programação se dá por diferentes interfaces, e o seu desenvolvimento seguindo princípios fundamentados em teorias como o construcionismo já ocorre desde a linguagem Logo. Esses princípios têm como influência o construtivismo de Piaget, que apontou a necessidade de materiais concretos para apoiar o raciocínio. Neste sentido, os princípios do currículo em espiral de Bruner também influencia a construção de brinquedos de modo que possuam interfaces de programação com níveis crescentes de poder e complexidade. Exemplos são apresentados na \autoref{secao_mapeamento_industrial}.

\section{Pensamento Computacional}
\label{fundamentacao_pc}
%Existem múltiplas definições de \acl{PC} \cite{barr_bringing_2011}. Ressaltam aspectos..

O \acl{PC} é um termo utilizado inicialmente por \citeonline{papert_mindstorms:_1980}, mas que tem recebido maior atenção a partir de 2006, quando Jeannette Wing publicou o artigo opinativo intitulado “Computational Thinking”\ na revista \textit{Communications of the ACM} \cite{wing_computational_2006}. No artigo, Wing define o \ac{PC} como “[...] conjunto de atitudes e habilidades universalmente aplicáveis que todos, não apenas os cientistas da computação, estariam ansiosos por aprender e usar” \cite[p.33, tradução nossa]{wing_computational_2006}. Considerando essa universalidade de aplicações, Wing afirma que o \ac{PC} deve ser aprendido pelas crianças assim como a escrita, leitura e matemática. Em trabalhos posteriores a autora menciona que o \acl{PC} é um processo de pensar um problema para admitir uma solução computacional. Essa solução pode ser gerada por uma máquina, por um humano, ou pela combinação de ambos. Em 2014, Wing acrescenta que o \ac{PC} não trata apenas de como resolver problemas, mas também de como formulá-los \cite{wing_computational_2014}.

\citeonline{barr_bringing_2011} afirmam que uma definição de \ac{PC}, para ter utilidade, precisa trazer exemplos de como incorporá-lo aos ambientes educacionais. Neste sentido cerca de 700 professores da \ac{ISTE} ISTE (\textit{International Society for Technology in Education} — Sociedade Internacional para Tecnologia na Educação) e da \ac{CSTA} desenvolveram uma “definição operacional” do \acl{PC}. Essa definição caracteriza o \ac{PC} como um processo de resolução de problemas, que inclui (mas não se limita) a:

\begin{itemize}
    \item Formular problemas de forma que um computador possa auxiliar a resolvê-los;
    \item Organizar e analisar dados logicamente;
    \item Representar dados através de abstrações, como modelos e simulações;
    \item Automatizar soluções através de pensamento algorítmico (série de passos ordenados);
    \item Identificar, analisar e implementar possíveis soluções para alcançar a combinação mais eficiente e eficaz de processos e recursos;
    \item Generalizar e transferir o processo de solução do problema para outros problemas.
\end{itemize}

\citeonline{brackmann_desenvolvimento_2017}, a partir da definição de \citeonline{bbc_learning_what_2015}, descreve o \ac{PC} em quatro pilares (\autoref{quadro_pc_pilares}): decomposição, reconhecimento de padrões, abstração e algoritmos. Esses quatro pilares podem ser aplicados para solucionar problemas complexos. O problema pode ser inicialmente quebrado em partes menores e mais simples de compreender e organizar (decomposição). Essas partes podem ser analisadas para verificar se alguma solução existente se aplica ao subproblema atual (reconhecimento de padrões), e também verificar quais informações são relevantes para solucioná-lo (abstração). Por último, um conjunto de passos descreve a solução de cada subproblema (algoritmo). O \autoref{quadro_pc_pilares} exemplifica a aplicação de cada pilar.

\begin{landscape}
    \begin{quadro}[!htbp]
     \captionquadro{Pilares do \acl{PC}.}
    \label{quadro_pc_pilares}
    \begin{center}
        \begin{footnotesize}
        \begin{tabular}{|p{6cm}|p{9cm}|p{5cm}|}
        \hline
            \textbf{Pilar} & \multicolumn{2}{c|}{\textbf{Exemplo}} \\ \hline
            
            \textbf{Decomposição}: Separar partes que constituem um todo,  potencialmente facilitando a resolução de problemas.
            &
            Na escrita de um texto, em vez de escrever o texto completo de uma única vez, a tarefa pode ser decomposta em introdução, desenvolvimento e conclusão. O desenvolvimento pode então ser decomposto em um conjunto de ideias a serem transmitidas com parágrafos. Até mesmo os parágrafos podem ser decompostos, com uma frase inicial, uma ou mais frases de suporte e uma frase de conclusão \cite{davidson_12_2018}.
            
            &
            
            \begin{center}
                \includegraphics[width=1\linewidth]{figs/decomposition.png}    
            \end{center}
            
            \\ \hline
            
            \textbf{Reconhecimento de Padrões}: Identificar similaridades entre as partes de um problema para resolvê-las com eficiência \cite{bbc_learning_what_2015}. Na Ciência da Computação os padrões reduzem a complexidade por meio da generalização de soluções para aplicá-las em múltiplas situações \cite{k-12_computer_science_framework_k12_2016}.
            &
            Um exemplo é reconhecer padrões em sequências de cores. A primeira vista são apenas círculos coloridos, mas é possível identificar o padrão sequencial de cores em cada linha. Outros exemplos são identificar rotas comuns entre casa e trabalho para organizar caronas, identificar o padrão de compras de um consumidor, e também reconhecer sintomas similares de doenças entre pacientes.
            &
            \begin{center}
                \includegraphics[width=1\linewidth]{figs/pattern_recognition.png}    
            \end{center}
            \\ \hline
            \textbf{Abstração}: Destacar detalhes importantes e ignorar detalhes desnecessários \cite{wing_computational_2008}. A abstração elimina os detalhes específicos, inúteis para resolver um problema, e cria uma ideia base da solução denominada modelo \cite{bbc_learning_what_2015}.
            &
            Durante o treinamento de cães farejadores para resgate de seres humanos, um conjunto de testes avalia os animais em quesitos como inteligência, concentração, agilidade e capacidade olfativa. Dados como raça, tamanho, cor ou peso não influenciam na capacidade do cão desempenhar a tarefa em questão. É preciso, portanto, detectar as características relevantes ao problema no universo de características do animal \cite{davidson_12_2018}.
            &
            \begin{center}
                \includegraphics[width=1\linewidth]{figs/abstraction.png}    
            \end{center}
            
            \\ \hline
            \textbf{Algoritmos}: instruções que demonstram o passo a passo para resolver um problema. Esse conjunto de passos precisa ter um início, um fim, e uma sequência de instruções sem ambiguidade \cite{bbc_learning_what_2015}.
            
            &
            A representação desse conjunto de passos pode ocorrer por diferentes modos. Uma receita de bolo é um algoritmo, pois define o conjunto de passos para resolver o problema de criar um bolo. Neste caso a representação é textual, porém pode-se representar um algoritmo por fluxogramas, blocos, sequência de símbolos, etc.
            &
            \begin{center}
                \includegraphics[width=1\linewidth]{figs/algoritmo.png}    
            \end{center}
            
            \\ \hline
            
        \end{tabular}
         
        \end{footnotesize}
    \end{center}
    \end{quadro}
\end{landscape}

As definições de PC apresentadas estão relacionadas com resolução de problemas gerais, e não se restringem ao contexto da programação de algoritmos. Nessas definições, o conceito de depuração parece ter relevância secundária. Uma possível causa é o fato da depuração estar “embutida” na programação algoritmos, e não ser percebida como uma habilidade útil no dia a dia. \citeonline{mccauley_debugging_2008} comenta que até mesmo no campo da programação a depuração é negligenciada, afirmando que o livro de Barnes e Kölling (2002) é um dos poucos a dedicar um capítulo completo sobre depuração. A próxima seção busca esclarecer este conceito.

\subsection{Depuração}

A depuração é um conceito que foi particularmente discutido por pesquisadores e educadores nas décadas de 1970 \cite{mccauley_debugging_2008} e 1980 \cite{sipitakiat_robo-blocks_2012}. Mesmo já sendo praticada por programadores profissionais, foi o surgimento da linguagem Logo neste período que desencadeou estudos envolvendo depuração por crianças. A recente popularização do PC \cite{ilic_publication_2018} e o aumento do contato de crianças com algoritmos tem levado pesquisadores a discutirem o papel da depuração no aprendizado \cite{repiso_robotics_2019}.

A atividade de depurar está ligada à necessidade de corrigir partes de algoritmos que impedem a execução correta de um programa. No contexto educacional, este desejo cria uma situação propícia ao exercício de um conjunto maior de habilidades, como trabalho em equipe, comunicação e persistência \cite{sipitakiat_robo-blocks_2012}. Portanto, pode ser vista como uma atividade de resolver problemas, que envolve observar, comunicar e refletir. A depuração, bem como a ação de ler e acompanhar a execução passo a passo de programas existentes, são consideradas essenciais para aprender programação \cite{mccauley_debugging_2008} e contribuir para o desenvolvimento do \ac{PC}.

Entretanto, \citeonline{liu_understanding_2017} observam que a depuração é um componente do PC negligenciado principalmente nos níveis iniciais de ensino. Os avanços tecnológicos e o entusiasmo com a temática do PC tem levado estudantes iniciarem o aprendizado de programação mais jovens. Ainda assim, afirma que poucos ambientes de programação são projetados com foco em funcionalidades de depuração no nível da Educação Básica, e a maior parte das pesquisas sobre o tema ocorrem com estudantes em nível universitário.

\citeonline{brennan_new_2012} abordam a depuração em um framework de PC utilizado no contexto do ScratchJr. O framework tem três dimensões: conceitos, práticas e perspectivas. Os conceitos remetem aos conhecimentos utilizados e aprendidos durante a programação, como paralelismo, laços de repetição e dados. As práticas envolvem a aplicação desses conceitos utilizando de desenvolvimento iterativo, mesclagem de códigos e depuração. Por fim, as perspectivas são formas de se utilizar a tecnologia: como meio de expressão, conexão, e questionamento/mudança da realidade. Usando esse framework, \citeonline{lye_review_2014} revisaram a literatura em busca de trabalhos sobre PC. Eles observam que 85\% dos artigos analisaram os aprendizados de PC relacionados a conceitos, e apenas 22\% analisaram as práticas. Argumentam que por isso seria necessário mais trabalhos ligados a práticas computacionais como a depuração.

\citeonline{wong_computational_2018} relacionam pensamento algorítimico e depuração como duas sub-habilidades do PC. O pensamento algorítmico seria a capacidade de formular sequências de passos para solucionar um problema independente de computador. A depuração seria aplicada depois do pensamento algorítmico, ao traduzir o algoritmo para uma linguagem de programação e solucionar problemas no código do programa se este não gerar o resultado desejado. Papert, por outro lado, afirma que a depuração independe do computador, pois “estratégias de depuração foram desenvolvidas por estudantes de sucesso muito antes da existência dos computadores” \cite[p.23]{papert_mindstorms:_1980}. Seria, então, mais um processo mental do que o uso de ferramentas computacionais.

\citeonline{carver_assessing_1986} decompõem o processo da depuração em quatro etapas: (i) avaliar o programa, (ii) identificar o \bug, (iii) localizar o \bug, (iv) e corrigir o \bug. Em uma atividade com BPs, por exemplo (ver \autoref{fig_ex_carver_klar}), a criança executa o algoritmo e verifica se alcançou o resultado esperado. Caso contrário, precisa identificar o erro, por exemplo, se o brinquedo está no local errado, se virou para o lado errado, etc. Ainda na identificação, constrói hipóteses causas do problema. Faltou adicionar um comando de giro? O comando de giro está errado? A terceira etapa passa a ter contato com o código, onde a criança identifica qual peça pode ser o \bug. Por fim, na última etapa a criança modifica o programa, adicionando ou removendo a peça apontada na etapa 3 e o ciclo recomeça com uma nova execução.

\begin{figure}[!htpb]
  \centering
  \includegraphics[width=.8\linewidth,fbox]{figs/ex_depuracao_carver_klar.png}
  \caption{Processo de depuração proposto por \citeonline{carver_assessing_1986} no contexto de um BP. }
  \sourceauthor
  \label{fig_ex_carver_klar}
\end{figure}

Seguindo esse modelo, \citeonline{carver_assessing_1986} avaliaram o aprendizado de depuração por crianças entre 7 e 8 anos. As crianças trabalharam em pares durante 22 horas de curso sobre a linguagem Logo. Os pesquisadores aplicaram dois testes em dupla e um individual para avaliar a habilidade de depuração, interpretação de código, escrita de código e uso do ambiente Logo. Os resultados indicaram que as crianças depuraram somente quando lhes era solicitado, e que a estratégia utilizada para encontrar erros foi procurar linha por linha, sem uma estratégia eficiente. As crianças também preferiram apagar o programa em vez de depurar. Por fim, concluem que depurar é uma atividade complexa, que exige memória de trabalho para observar o programa criado e os problemas existentes. Além disso, menciona que o fato do erro ser punido pelo sistema educacional leva a criança a tentar eliminá-lo (apagar todo o programa) em vez de resolvê-lo.

\subsection{Depuração e visibilidade}
Em uma revisão sistemática, \citeonline{mccauley_debugging_2008} apresenta modelos de depuração definidos Vessey (1985) e Katz e Anderson (1987). Vessey (1985) define depuração em cinco passos: (i) determinar o problema comparando o resultado errado e o correto; (ii) \textit{obter familiaridade com a estrutura do programa}; (iii) explorar a execução do programa; (iv) levantar hipóteses para a causa do erro; e (v) reparar o erro. Katz e Anderson (1987) definem quatro passos: (i) entender o sistema, (ii) testar o sistema, (iii) \textit{localizar o erro}, e (iv) reparar o erro.

\begin{figure}[!htpb]
  \centering
  \includegraphics[width=.9\linewidth,fbox]{figs/debug_models.png}
  \caption{Modelos de depuração.}
  \sourceauthor
  \label{fig_debug_models}
\end{figure}

Estes modelos têm em comum um passo de observar a estrutura do algoritmo para localizar o erro (destacados na \autoref{fig_debug_models}). A localização do erro presume um código-fonte a ser analisado. Essa necessidade está ligada ao que \citeonline{norman_design_1990} apresenta como um dos princípios mais importantes do design: a visibilidade. Esse princípio permite o “mapeamento entre as ações pretendidas e as ações concretas” \cite{norman_design_1990}. Para isso, as ações possíveis de se realizar com uma interface devem estar visíveis e seus efeitos devem ser óbvios e imediatos.

Interfaces de programação que não atendem o princípio da visibilidade dificultam a depuração. Este problema aparece em ferramentas projetadas para crianças, como a Bee-Bot. A sua interface tem botões direcionais e um botão de limpeza de memória, que apaga os comandos inseridos. O brinquedo não tem um \textit{display} para mostrar os comandos digitados. Ao não ver os comandos, as crianças esquecem de limpar a memória e então pensam estar construindo um programa novo \cite{raabe_brinquedos_2015}. A falta de visibilidade impede perceber que os comandos inseridos anteriormente ainda estão presentes e os novos comandos são adicionados no final da sequência.

Durante este processo ocorre um fenômeno mencionado por \citeonline{norman_design_1990} como a formação do \destaque{modelo mental} do usuário. O modelo mental é a compreensão que o usuário tem sobre quais ações deve comunicar a um sistema para obter um resultado desejado. A construção do modelo mental depende que o usuário perceba o estado atual do dispositivo, e como ele se modifica conforme as entradas informadas. Quando a interface com o dispositivo não é clara ou a apresentação do estado ambíguo, o comportamento do dispositivo pode não se adequar ao modelo mental construído pelo usuário.

A questão é que, quando o inesperado acontece, o cérebro humano tenta explicar e acomodar essa nova situação. No caso da Bee-Bot, ao vê-la executar movimentos diferentes dos últimos comandos programados — que ocorre pela diferença entre o modelo pensado pela criança e o estado real do brinquedo — as crianças tendem a explicar que “abelha” está “tomando suas próprias decisões”. A criança, portanto, adapta o seu modelo mental para explicar o comportamento do dispositivo computacional quando este não executa a sequência de passos que recém-programados.

Uma alternativa para interfaces com o problema de falta de visibilidade são os ambientes de programação em blocos (\autoref{sec_prog_blocos}). \citeonline{wong_computational_2018} atribuem a melhoria na habilidade de depuração de crianças do quinto ano do Ensino Fundamental às “características de visualização da programação em blocos, pois os efeitos do programa podem ser vistos diretamente”. \citeonline{bers_coding_2019} falam sobre as vantagens de visualização das interfaces de programação em blocos, neste caso blocos tangíveis:

\begin{citacao}
As crianças podem ver o que não funciona e podem ajudar a consertar. [...] A visibilidade adicional do código pode chamar a atenção para propriedades e conceitos anteriormente negligenciados, como elegância, a importância da depuração e teste para casos extremos e outras situações incomuns. Em outras palavras, o código tem o potencial de se tornar um objeto de conversa e atenção de uma forma que não poderia ser antes. \cite[p.14, tradução nossa]{bers_coding_2019}
\end{citacao}

Além de promover a visibilidade, a programação em blocos evita problemas de interação presentes em outras categorias de interfaces, como a programação textual.
Esta, apesar de também mostrar os comandos, não é acessível para crianças devido a erros de sintaxe e à necessidade de lembrar o que é preciso digitar. Os blocos, por outro lado, estão sempre disponíveis, geralmente agrupados por similaridade, de modo que não seja necessário lembrar sequências de caracteres para digitar num teclado. Além disso, o formato dos encaixes sugere como relacionar os blocos de modo coerente.

A visibilidade da programação em blocos também favorece a interação social. Os blocos visíveis podem ser apontados, manipulados, e tornam o código um objeto de conversa. O mesmo ocorre com a depuração, que pode ser uma atividade estabelecida socialmente com falas, gestos e olhares. Neste sentido, os blocos são artefatos com papel central \cite{heikkila_debugging_2018} ao depurar. Esta ligação entre blocos e depuração remete ao princípio da linguagem Logo, de permitir depurar o que se passa na mente da criança \cite{solomon_history_2020}. Os artefatos compartilhados socialmente se tornam mais um meio de comunicação para o adulto compreender o algoritmo que a criança deseja expressar. Deste modo pode auxiliá-la a desenvolver seu modelo mental de como construir um algoritmo e resolver um problema.

\section{Interfaces de Programação para Crianças}
\label{section_interfaces}

Aprender programar algoritmos parece ser uma tarefa difícil, mesmo para adultos. Analisando cursos de graduação em Computação de universidades dos Estados Unidos, Israel, Polônia e Austrália, \citeonline{mccracken_multi-national_2001} concluíram que os estudantes não possuíam as habilidades de programação esperada pelos professores, indicando dificuldade no aprendizado de algoritmos. \citeonline{hoed_alise_2016} cita a reprovação na disciplina de Algoritmos entre as causas de evasão em cursos de Computação.

Mesmo sendo um conteúdo complexo, crianças podem aprender noções básicas algoritmos. \citeonline{sheehan_parent-child_2019}, observaram 31 crianças de 4,5 a 5 anos, durante a interação com um aplicativo de programação, e concluem que elas conseguiram produzir e compreender algoritmos básicos para definir o comportamento de um personagem. Em outro estudo, com 53 crianças de 4 a 6 anos, \citeonline{bers_computational_2014} identificam que 75\% das mesmas selecionaram e sequenciaram corretamente instruções ao programar um veículo robótico.

Os benefícios de aprender algoritmos transcendem os campos estritamente tecnológicos. Conforme lembram \citeonline{ciftci_effect_2020}, os algoritmos possuem conceitos que se intersectam com os da matemática, como variáveis, laços de repetição e condicionais. Esses autores também afirmam que programar pode auxiliar estudantes a analisarem seu modo de raciocínio, reorganizar tarefas seguindo um processo de resolução de problemas e desenvolver habilidades não-verbais. Em experimento, os autores verificaram um aumento significativo dessas habilidades em crianças de 4 a 5 anos que participaram de um curso de programação durante 8 semanas.

Para \citeonline{papert_mindstorms:_1980},

\begin{citacao}
Quando a criança aprende a programar, o processo de aprendizado é transformado. Ele se torna mais ativo e autodirigido. Em particular, o conhecimento é adquirido para um propósito pessoal reconhecido. A criança faz algo com ele. O novo conhecimento é uma fonte de poder sendo experimentado como tal desde o momento em que começa a tomar forma na mente da criança \cite[p.21, tradução nossa]{papert_exploration_1996}.
\end{citacao}

Uma das primeiras experiências envolvendo crianças e programação é atribuída a Papert e Cynthia Solomon em 1968. Ambos foram até uma escola de um subúrbio de Boston ensinar programação para jovens. As interações ocorreram através de terminais, que recebiam comandos em Logo e executavam em um computador do laboratório a alguns quilômetros de distância.

Conforme novas versões da linguagem eram desenvolvidas, pesquisadores as testavam em escolas ao ensinar e observar o uso da linguagem em sala de aula \cite{bers_coding_2018}. Solomon destaca o papel da participação das crianças durante o desenvolvimento da linguagem, dando \textit{feedback} e influenciando diversas questões de design:

\begin{citacao}
O trabalho iniciou o que se tornou uma linguagem poderosa, flexível e usável para crianças e destacou a facilidade com que os aprendizes adquiriram experiência sobre a ferramenta. O trabalho é também um importante exemplo de envolvimento das crianças no design de uma nova tecnologia e de como a tecnologia pode se beneficiar da expertise e do \textit{feedback} das crianças. Cada vez que Seymour e eu trabalhamos com as crianças, LOGO foi radicalmente redesenhada incorporando o seu \textit{feedback}.
\end{citacao}

A linguagem LOGO inicialmente permitia manipular palavras, e as crianças construíam poemas e geradores de frases. Papert, um matemático, percebeu a necessidade transcender o campo das palavras e de permitir às crianças brincarem com formas, ângulos e desenhos. Dessa percepção nasceu a ideia de uma tartaruga capaz de se mover e desenhar figuras geométricas. Essa tartaruga foi introduzida primeiro virtualmente, mas depois tomou formas físicas e originando os primeiros brinquedos programáveis.

\subsection{Brinquedos Programáveis}
\label{brinquedos_programaveis}
Brinquedos programáveis podem ser caracterizados, em sua maioria, como robôs sobre rodas que recebem comandos e executam em forma de movimentos\footnote{Há brinquedos que não são robóticos, como o \href{https://www.thinkfun.com/products/robot-turtles/}{Robot Turtles}, um jogo de tabuleiro com conceitos de programação.}. O que os diferencia das outras ferramentas de programação é a aparência lúdica, adaptada ao imaginário do público infantil \cite{raabe_2017_rope}. Pesquisas mencionam que os brinquedos programáveis podem promover habilidades relacionadas do \ac{PC} \cite{repiso_robotics_2019, bers_coding_2018, pugnali_impact_2017,  bers_computational_2014}, como pensamento algorítmico, reconhecimento de padrões, abstração e decomposição.

A interface intuitiva é o que permite que crianças possam programar esses brinquedos. Diferente de teclado de computador, eles geralmente têm poucos botões e não exigem alfabetização. O desenvolvimento dessas interfaces se inicia com o ambiente Logo, e diversas alternativas de interação têm surgido nos últimos anos \cite{catlin_edurobot_2018}.

\citeonline{hamilton_emerging_2020} apresentam 30 brinquedos e os classificam segundo suas características físicas em seis categorias: (i) jogos de tabuleiro ou livros; (ii) eletrônicos não robóticos; (iii) robôs controlados por tela; (iv) robôs operados por botões; (v) robôs com interface tangível; e (vi) híbridos \autoref{hamilton}.

\begin{figure}[!htpb]
  \centering
  \includegraphics[width=.9\linewidth,fbox]{figs/hamilton_classification.png}
  \caption{Classificação de brinquedos programáveis por características físicas.}
  \source{ Adaptado de \citeonline{hamilton_emerging_2020}.}
  \label{hamilton}
\end{figure}

Em outra revisão, \citeonline{yu_review_2019} também analisam um conjunto de 30 brinquedos programáveis e kits de robótica focados em crianças de até 7 anos. A análise ocorre sob as perspectivas de design, \acl{PC}, expressividade e suporte a domínios\footnote{
A expressividade corresponde à variedade de atividades possibilitadas pelo kit, e o suporte a domínios se refere ao conjunto de assuntos/conteúdos passíveis de serem apresentados no contexto dessas atividades.
}.

Quanto ao design, \citeonline{yu_review_2019} distinguem três categorias de kits: físicos, virtuais e híbridos. As três categorias têm o comum a utilização de blocos de código relacionados a movimentos, com cada bloco tendo uma cor diferente para auxiliar na distinção dos diferentes
comandos. Esses blocos comumente tem o formato de peças de quebra-cabeça. Os kits físicos, como KIBO e Cubetto, possuem todos os componentes tangíveis, geralmente incluindo um robô com rodas, um conjunto de blocos de código e materiais de suporte como mapas, livros e materiais de personalização. Alguns robôs são controlados por botões, mas a maioria tem blocos de códigos separados.

Os kits virtuais são aqueles que não possuem partes tangíveis. Exemplos são aplicativos de \textit{smartfone} e jogos de computador, que possibilitam construir cenas, programar personagens e resolver problemas ao arrastar e soltar blocos de código virtuais. O Scratch e o ScrachJr são aplicativos que permitem construir cenas e programar personagens. Essa categoria remete às primeiras experiências de Papert durante o desenvolvimento da linguagem LOGO, que permitia definir o comportamento da tartaruga virtual. A diferença é que as ferramentas atuais priorizam o uso de linguagens de blocos.

A terceira categoria são os kits híbridos, que unem partes tangíveis e virtuais. \citeonline{yu_review_2019} destacam duas classes de kits híbridos: aqueles com blocos físicos que controlam personagens virtuais (brinquedos da empresa Osmo, por exemplo\footnote{\url{https://www.playosmo.com/en/coding/}}), e aqueles que possuem blocos virtuais para controlar personagens físicos.

Quanto ao \acl{PC}, \citeonline{yu_review_2019} relacionam atividades possibilitadas pelos BPs e kits capazes de promover os conceitos e práticas ligadas ao \ac{PC} definidas por \citeonline{brennan_new_2012}. Os autores identificam que as atividades com BPs podem abordar todos os conceitos e práticas do \ac{PC}. Há poucos kits, porém, que suportam as práticas de reutilização/combinação e abstração/modularização.

\begin{quadro}[!htbp]
 \captionquadro{Como brinquedos programáveis e kits promovem conceitos e práticas computacionais.}
 \label{quadro_brinquedos_praticas}
 \begin{center}
 \begin{footnotesize}
\begin{tabular}{|p{3cm}|p{12cm}|}
\hline
\multicolumn{2}{|c|}{\textbf{Conceitos}} \\ \hline

    Sequenciamento & Criar uma sequência de código para programar o movimento ou outros efeitos em robôs físicos/virtuais. \\ \hline
    
    Repetições & Encapsular uma sequência de comandos em blocos de repetição para executar repetidas vezes. \\ \hline
    
    Eventos & Executar ações ao apertar botões específicos, ou programar efeitos durante interações entre brinquedos (por exemplo, Dash e Dot executam ações quando se aproximam um do outro). \\ \hline
    
    Paralelismo & Controlar o movimento de diversos robôs/sprites simultaneamente, ou programar efeitos simultâneos de movimento, luzes e sons. \\ \hline
    
    Condicionais & Programar ações dependentes de eventos disparados por sensores ou mapas. \\ \hline
    
    Operadores & Possibilitar realizar operações matemáticas simples. \\ \hline
    
    Dados & Ajustar parâmetros como distância do movimento, rotação, etc. \\ \hline

\multicolumn{2}{|c|}{\textbf{Práticas}} \\ \hline

    Desenvolvimento iterativo e incremental & Permitir erros e tentativas ilimitados. Constantemente revisar e adicionar novos blocos de código (ex. ScratchJr). \\ \hline
    
    Teste e depuração & Testar continuamente o código durante o desenvolvimento e depurar se algo não funciona. \\ \hline
    
    Reutilização e combinação & Construir projetos partindo de projetos anteriores (ex. Scratch). A maioria dos kits não suporta essa prática. \\ \hline
    
    Abstração e modularização & Construir blocos de código que podem ser chamados de outros locais (ex. Cubetto). Poucos kits suportam essa prática. \\ \hline

\end{tabular}
 
 \end{footnotesize}
 \end{center}
 \source{Adaptado de \citeonline{yu_review_2019}.}
\end{quadro}

Quanto à expressividade, ou seja, as atividades que os brinquedos possibilitam, os autores citam três principais modalidades. A primeira corresponde a mover o brinquedo/kit por um caminho ou sobre um mapa para coletar objetos. A segunda modalidade é a contação de histórias: os brinquedos se movem sobre cenários, e as crianças podem criar histórias para os mesmos em conjunto com a família. Há também uma terceira atividade: decorar e personalizar a aparência do brinquedo.

Quanto ao suporte a domínios, \citeonline{yu_review_2019} mencionam o desenvolvimento de narrativas, conceitos matemáticos e conceitos de engenharia. O desenvolvimento de narrativas está ligado às atividades de contação de histórias. O Scratch, por exemplo, possibilita criar narrativas por meio da programação de personagens e definição de cenários. Conceitos matemáticos aparecem ao definir distâncias de movimentos, e operações aritméticas simples também estão presentes em alguns brinquedos. Os conceitos de engenharia são abordados em brinquedos onde é possível unir partes diversas e observar efeitos, como o caso do Cubelets\footnote{\url{https://www.modrobotics.com/\#whatr-cubelets}}, que permite à criança unir cubos de luminosidade, sensores e movimentos.

As classificações de \citeonline{hamilton_emerging_2020} e de \citeonline{yu_review_2019} se diferem quanto aos critérios utilizados. Enquanto \citeonline{hamilton_emerging_2020} não inclui em sua lista os kits robóticos e softwares exclusivamente gráficos, \citeonline{yu_review_2019} inclui ambos. Ambos os trabalhos, porém, focam no público infantil, e as análises das interfaces e dos conceitos promovidos são úteis para definir as características do brinquedo RoPE.

\subsubsection{RoPE - Robô Programável Educacional}
O RoPE é um brinquedo programável desenvolvido para crianças a partir de 3 anos, que busca estimular o \acl{PC}. Ele permite à criança inserir comandos que ele então executa como movimentos sobre um tapete temático. A construção tem preocupações de design relacionadas ao público e ao ambiente. O público tem coordenação motora em desenvolvimento e isso reflete o tamanho dos botões. As cores dos botões facilitam a comunicação das professoras para indicarem um botão específico durante alguma explicação no ambiente educacional.

\begin{figure}[!htpb]
  \centering
  \includegraphics[width=.9\linewidth,fbox]{figs/rope_up_front.png}
  \caption{Visão superior e frontal do RoPE.}
  \source{Smartfun Brasil (\url{https://www.smartfun.com.br}).}
  \label{rope}
\end{figure}

O RoPE pode ser operado de duas formas: botões na parte superior e um aplicativo de \textit{smartphone}. A primeira interface é formada por 5 botões que fazem parte do brinquedo. São eles: (1) amarelo para girar 90 graus à esquerda, (2) vermelho para girar 90 graus à direita, (3) azul para andar à frente (4) laranja andar para trás, e (5) verde para executar instruções inseridas. A execução de cada instrução provoca, além do movimento, a emissão de um som característico e uma luz da mesma cor do botão gerador da instrução, para haver uma tríade cor-movimento-som. Um som de finalização indica quando o brinquedo executou todas as instruções \cite{raabe_2017_rope}.

A segunda interface é um aplicativo de celular que permite programar o RoPE a distância (\autoref{rope_app}). O programa aparece na tela em formato de peças de quebra-cabeça conectadas. A comunicação Bluetooth entre o brinquedo e o aplicativo possibilita manter as peças e as instruções da memória em sincronia. A reordenação das peças no aplicativo é replicada no brinquedo e o pressionamento de um botão do brinquedo é replicado nas peças na tela do celular. Considerando a possibilidade de programar por duas interfaces, as classificações de \citeonline{hamilton_emerging_2020} e \citeonline{yu_review_2019} posicionam o RoPE como um brinquedo híbrido.

\begin{figure}[!htpb]
  \centering
  \includegraphics[width=.9\linewidth,fbox]{figs/app.jpg}
  \caption{Aplicativo para programar o RoPE.}
  \sourceauthor
  \label{rope_app}
\end{figure}

O \autoref{quadro_rope_pc} classifica o RoPE quanto aos aspectos do \acl{PC}. Os conceitos abordados pelo brinquedo são sequenciamento, eventos e dados. O brinquedo aborda diretamente apenas sequenciamento e eventos, porém as professoras podem abordar o conceito de dados durante o uso do brinquedo, ao definir distâncias e posições a serem alcançadas. O brinquedo não abrange todas as práticas e conceitos, pois o público-alvo exige um design simples de usar.

\begin{quadro}[!htbp]
 \captionquadro{Conceitos e práticas computacionais e sua promoção pelo brinquedo RoPE.}
 \label{quadro_rope_pc}
 \begin{center}
 \begin{footnotesize}
\begin{tabular}{|p{5cm}|p{10cm}|}
\hline
\multicolumn{2}{|c|}{\textbf{Conceitos}} \\ \hline
    
    Sequenciamento & Criar uma sequência de comandos para guiar o movimento do RoPE sobre um mapa. \\ \hline
    
    Repetições & \notcovered \\ \hline
    
    Eventos & O evento de clicar na estrela inicia a execução dos comandos inseridos previamente. \\ \hline
    
    Paralelismo & \notcovered \\ \hline
    
    Condicionais & \notcovered \\ \hline
    
    Operadores & \notcovered \\ \hline
    
    Dados & Estimar o número de passos para alcançar uma posição no mapa. \\ \hline

\multicolumn{2}{|c|}{\textbf{Práticas}} \\ \hline

    Desenvolvimento iterativo e incremental & Não abordado diretamente, pois as instruções são apagadas do brinquedo ao final de cada execução. \\ \hline
    
    Teste e depuração & Testar continuamente o código durante o desenvolvimento e depurar se algo não funciona. \\ \hline
    
    Reutilização e combinação & \notcovered \\ \hline
    
    Abstração e modularização & \notcovered \\ \hline

\end{tabular}
 
 \end{footnotesize}
 \end{center}
 \sourceauthor
\end{quadro}

Além de aspectos ligados ao PC, o RoPE suporta domínios multidisciplinares através de tapetes temáticos, nos quais as crianças têm contato com letras do alfabeto (\autoref{tapete_alfabeto}), temáticas dos ambientes rurais (\autoref{tapete_farm}) e urbanos (\autoref{tapete_city}). \citeonline{pinheiro_alise_2016} desenvolveu um software que permite à criança gerar seus próprios mapas e percebeu mais engajamento das crianças ao usarem seus próprios mapas. Esses tapetes também podem ser criados manualmente, como o tapete criado pelas crianças da \autoref{tapete_alfabeto}. Além de criar os próprios tapetes \citeonline{martins_desenvolvimento_2016} também menciona a possibilidade de customizar a carcaça do brinquedo. Então, apesar de a interface do brinquedo favorecer raciocínio matemático de estimar quantidades e movimentos, a customização e os tapetes possibilitam criar micromundos infinitos associados a qualquer temática.

\begin{figure}[!htbp]
    \centering
    \begin{subfigure}{.33\textwidth}
        \centering
        \includegraphics[width=.9\linewidth,fbox]{figs/tapete_alfabeto.png}
        \caption{Letras do alfabeto}
        \label{tapete_alfabeto}
    \end{subfigure}%
    \begin{subfigure}{.33\textwidth}
        \centering
        \includegraphics[width=.9\linewidth,fbox]{figs/tapete_farm.png}
        \caption{Ambiente rural}
        \label{tapete_farm}
    \end{subfigure}
    \begin{subfigure}{.33\textwidth}
        \centering
        \includegraphics[width=.9\linewidth,fbox]{figs/tapete_city.png}
        \caption{Ambiente urbano}
        \label{tapete_city}
    \end{subfigure}
    \caption{Tapetes temáticos.}
    \source{\cite{raabe_2017_rope}}
    \label{rope_mats}
\end{figure}

\subsection{Interfaces Tangíveis}
\label{fundamentacao_sub_interfaces_tangiveis}
Como abordado na \autoref{brinquedos_programaveis}, as interfaces tangíveis são interfaces utilizadas pelos brinquedos de programar. O conceito de interfaces tangíveis, entretanto, é amplo e tem fronteiras difusas \cite{falcao_design_2007}. A ideia inicial sobre tangibilidade é que apresenta formas físicas de interação, que permitem o contato da mão com objetos concretos. Essa interação é considerada mais intuitiva e capaz de estimular colaboração e diversão (ZUCKERMAN; GAL-OZ, 2013). A tangibilidade dos blocos de encaixar, como LEGO, por exemplo, leva crianças a permanecerem horas manipulando-os e testando possibilidades de construções.

A ideia de manipulação de objetos concretos não delimita completamente o que são interfaces tangíveis. Dado que são manipulados diretamente, “teclados são TUIs?” \cite[p.30]{falcao_design_2007}. Neste sentido, diferentes taxonomias buscam organizar a definição de interfaces tangíveis \cite{fishkin_taxonomy_2004, fincher_tangible_2019}. \citeonline{fishkin_taxonomy_2004}, por exemplo, observa a sequência de ações do usuário durante uma interação. Em toda interação, o usuário manipula uma interface e em seguida observa o resultado da manipulação. A taxonomia considera a distância estão os pontos de manipulação e o ponto de expressão do resultado, ao que denomina “incorporação”. Quanto mais próximas estão a manipulação e o resultado, maior a incorporação. Há quatro níveis de incorporação das interfaces tangíveis \cite{fishkin_taxonomy_2004}:

\begin{description}
    \item[Completa:] O ponto de manipulação é o mesmo que expressa o resultado. Um exemplo é o ábaco.
    \item[Próxima:] A expressão do resultado ocorre próxima do ponto de manipulação. Uma caneta é um exemplo.
    \item[Ambiental:] A expressão do resultado está “ao redor” do usuário. Um exemplo seria uma sala com projeção nas paredes.
    \item[Distante:] O ponto de manipulação e a expressão do resultado ficam em salas separadas, ou a metros de distância. O controle remoto é um exemplo.
\end{description}

\citeonline{fincher_tangible_2019} apresentam a ideia de linguagens tangíveis de programação. Neste caso, elementos tangíveis são agrupados para construir um significado, que no caso correspondem a um algoritmo. Há três categorias de linguagem tangíveis:

\begin{description}
    \item[Linguagens de blocos inteligentes:] Blocos físicos com componentes eletrônicos internos. Eles conseguem armazenar instruções digitais e executá-las. Um exemplo é o Cubelets.
    
    \item[Linguagens de demonstração:] O usuário demonstra ao dispositivo o que deve ser executado e então ele reproduz. A demonstração pode ocorrer com gestos, sons ou entradas digitais (botões).
    
    \item[Linguagens externamente compiladas:] A representação do algoritmo ocorre por símbolos sem componentes eletrônicos. Algum agente externo, como uma câmera, capta os símbolos e os transmite como entradas digitais que podem ser convertidas em um programa. Exemplos são blocos de madeira, como os utilizados pelo brinquedo KIBO: um escaner lê cada bloco e o transmite ao brinquedo. Ao escanear uma sequência válida o brinquedo pode executar o algoritmo.
\end{description}

Por fim, \citeonline{falcao_design_2007} responde a própria pergunta: teclados e mouse não são TUIs, pois não carregam um significado. Ao contrário, são dispositivos genéricos capazes de gerar significados variados. Por outro lado, o ábaco é uma interface tangível, pois traz incorporado o significado numérico. Blocos de madeira, como os usados pelo KIBO, é uma linguagem externamente compilada, que pode ser organizado para formar um algoritmo.

\subsection{Programação em Blocos}
\label{sec_prog_blocos}
Programação em blocos tem se tornado um meio comum de iniciar o aprendizado de programação \cite{weintrop_block-based_2019}. Ferramentas como o Scratch, ScratchJr e o Code.org utilizam essa abordagem. No Brasil, mais de 40\% das iniciativas para ensino de programação adotou ambientes baseados em blocos para introduzir os primeiros conceitos \cite{bordini_computacao_2016}.

A programação em blocos se caracteriza por blocos a peças de quebra-cabeça, que encaixados representam um algoritmo. As cores e o formato indicam quando e como cada bloco pode ser usado. Os encaixes entre os blocos só permitem unir blocos que fazem sentido estarem unidos, evitando erros de sintaxe \cite{weintrop_block-based_2019}. Além disso, o usuário pode explorar os blocos disponíveis em vez de lembrar palavras a serem digitados.

Outro aspecto da programação em blocos é a exigência ou não de alfabetização. Há blocos que contém texto, o que aumenta a complexidade para crianças em processo de alfabetização \cite{flannery_designing_2013}. Um exemplo é o Scratch (\autoref{scratch_blocks}). O ScratchJr, por outro lado, é um ambiente de programação desenvolvido para crianças não alfabetizadas. Enquanto o Scratch usa texto, o ScratchJr tem ícones em seus blocos (\autoref{scratch_jr_blocks}).

\begin{figure}[!htbp]
    \centering
    \begin{subfigure}{.35\textwidth}
        \centering
        \includegraphics[width=.9\linewidth,fbox]{figs/scratch_blocos.png}
        \caption{Blocos do Scratch}
        \label{scratch_blocks}
    \end{subfigure}%
    \begin{subfigure}{.65\textwidth}
        \centering
        \includegraphics[width=.9\linewidth,fbox]{figs/scratch_jr.png}
        \caption{Blocos do ScratchJr}
        \label{scratch_jr_blocks}
    \end{subfigure}
    \caption{Blocos do Scratch e do ScratchJr.}
    \label{scratch_scratch_jr_blocks}
\end{figure}

Além dos ambientes gráficos, a programação em blocos também existe em interfaces tangíveis. Os blocos gráficos mitigam a necessidade de digitação, porém ainda dependem do mouse ou telas sensíveis ao toque para arrastar e soltar os blocos. Os blocos físicos eliminam essa necessidade, permitindo a manipulação direta e natural. O Osmo (\autoref{osmo_blocks}) é um exemplo de uso de blocos tangíveis de programação. Os blocos são identificados pela câmera de um tablet, e um personagem na tela executa os comandos programados. O Cubetto, já apresentado, utiliza blocos encaixados em um painel de madeira (\autoref{cubetto_blocks}).

\begin{figure}[!htbp]
    \centering
    \begin{subfigure}{.56\textwidth}
        \centering
        \includegraphics[width=.9\linewidth,fbox]{figs/osmo.jpg}
        \caption{Osmo}
        \source{Tangible Play \url{https://www.playosmo.com}}
        \label{osmo_blocks}
    \end{subfigure}%
    \begin{subfigure}{.43\textwidth}
        \centering
        \includegraphics[width=.9\linewidth,fbox]{figs/cubetto.jpg}
        \caption{Cubetto}
        \source{PrimoToys \url{https://www.primotoys.com}}
        \label{cubetto_blocks}
    \end{subfigure}
    \caption{Blocos tangíveis.}
    \sourceauthor
    \label{tangible_blocks}
\end{figure}

Uma vantagem do painel do Cubetto é indicar, com luzes, qual bloco está sendo executado em cada momento. Isso permite acompanhar a execução, o que é um processo de depuração. Possíveis desvantagens do painel são a limitação do número de encaixes disponíveis e a necessidade de um hardware específico.

\subsection{Marcas Fiduciais}
\label{sub_sec_fiduciais}
Interfaces tangíveis aplicam diferentes técnicas de captura de blocos físicos. O Cubetto depende de um hardware específico para identificar os blocos encaixados em um painel, e o Osmo utiliza visão computacional. Uma alternativa que pode facilitar a demarcação de objetos físicos na construção de interfaces tangíveis, e também na construção de aplicações de Realidade Aumentada (\autoref{sub_sec_fiduciais}), são as marcas fiduciais.

Marcas fiduciais (\autoref{fiducial}) são padrões de figuras desenvolvidas para facilitar a identificação e localização de pontos de referências em imagens. Sistemas de marcas fiduciais são compostos por um modelos de marcas e um algoritmo capaz de identificá-las. Apesar de o campo da visão computacional ter evoluído a ponto de não depender de marcas artificiais para detectar objetos, o uso de marcas fiduciais pode aumentar a confiabilidade e velocidade de processamento em sistemas \cite{fiala_designing_2010}.

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.9\linewidth,fbox]{figs/fiducial_marks.png}
    \caption{Exemplos de marcas fiduciais.}
    \source{\citeonline{fiala_designing_2010}.}
    \label{fiducial}
\end{figure}

Códigos de barra e QR Codes não são considerados marcas fiduciais. O objetivo destes é carregar informações e não tem dados suficientes para permitir a sua localização. Entretanto, o uso de padrões bitonais (geralmente preto e branco) dos QrCodes e códigos de barra é aproveitado nas marcas fiduciais, dado que isso facilita a detecção quando há variações de luminosidade.

TopCodes\footnote{\url{http://users.eecs.northwestern.edu/~mhorn/topcodes/}} é uma biblioteca de visão computacional, de código aberto, projetada para permitir rápida detecção de marcas fiduciais. Além da identificação e da localização, a biblioteca informa o diâmetro e a orientação de cada marca. \citeonline{hu_strawbies_2015} implementaram uma linguagem de blocos tangíveis para programar o personagem do ambiente Osmo (\autoref{strawbies_topcodes}). \citeonline{viana_interface_2018} implementam um ambiente de algoritmos sonoros para deficientes visuais, onde cada marca fiducial representou um instrumento musical (\autoref{bateria_topcodes}).

Uma desvantagem dessa abordagem é o fato de o usuário encobrir as marcas durante a manipulação. A não detecção de uma peça pode prejudicar o desempenho de sistemas que precisam detectar objetos constantemente. Esse problema, entretanto, não é relatado nos trabalhos mencionados.

\begin{figure}[h!]
    \centering
    \begin{subfigure}{.4\textwidth}
        \centering
        \includegraphics[width=.9\linewidth,fbox]{figs/topcodes_osmo.png}
        \caption{Tablet captura marcas fiduciais}
        \source{\citeonline{hu_strawbies_2015}.}
        \label{strawbies_topcodes}
    \end{subfigure}%
    \begin{subfigure}{.57\textwidth}
        \centering
        \includegraphics[width=.9\linewidth,fbox]{figs/topcodes_cassiano.png}
        \caption{Bateria de algoritmos sonoros tangível}
        \source{\citeonline{viana_interface_2018}.}
        \label{bateria_topcodes}
    \end{subfigure}
    \caption{Exemplos de uso da biblioteca TopCodes.}
    \label{topcodes_examples}
\end{figure}

\section{Realidade Aumentada}
\label{sec_realidade_aumentada}
A Realidade Aumentada (RA) é uma tecnologia que tem se popularizado nos últimos dez anos. Tem aplicações em inúmeros campos, entre os quais a medicina, a indústria, educação e entretenimento \cite{mekni_augmented_2014}. Apesar da popularização recente, as primeiras experiências com RA são atribuídas a Ivan Sutherland, que na década 1960 criou um dispositivo com pequenas telas próximas aos olhos, que permitiam ver o mundo real e adicionavam objetos virtuais adaptáveis às mudanças de perspectiva do usuário. Ainda hoje a RA se caracteriza por complementar a percepção do usuário ao associar elementos virtuais sobre elementos reais  \cite{parveau_3ivclass_2018}. Além da RA, existem outras técnicas que mostram elementos virtuais e proporcionam experiências realistas de interação, como a Realidade Virtual (RV). Essas técnicas se diferenciam pela quantidade de informação real ou virtual acessada.

Para melhor compreender essa associação \citeonline{milgram_augmented_1994} propõem o conceito de \textit{Virtual Continuum} (\autoref{fig_milgram}). Esse conceito tem de um lado a realidade, e do outro a virtualidade. A realidade está restrita a condições físicas, como gravidade e velocidade. A virtualidade, por outro lado, pode ter suas próprias regras. Entre os dois opostos há um intervalo que mistura real e virtual, denominado Realidade Mista (RM). A RA se encontra à esquerda neste intervalo, pois a maior parte da informação acessada pelo usuário existe no ambiente real, e apenas uma camada de objetos virtuais é adicionada. O conceito também apresenta a virtualidade aumentada, que seria a Realidade Virtual. Por ter a maior parte do conteúdo gerado pelo computador e apenas preservar alguns aspectos da realidade, a RV se encontra à direita no intervalo da Realidade Mista.

\begin{figure}[!htpb]
  \centering
  \includegraphics[width=.6\linewidth,fbox]{figs/milgram.png}
  \caption{\textit{Continuum} de realidade-virtualidade de Milgram (1994).}
  \source{Adaptado de \citeonline{milgram_augmented_1994}.}
  \label{fig_milgram}
\end{figure}

\citeonline{azuma_recent_2001} acrescenta outros dois princípios além da combinação de objetos virtuais e reais. Primeiro, o sistema deve responder em tempo real, de modo que as mudanças ocorram instantaneamente. Qualquer modificação de perspectiva ou de posicionamento dos objetos reais deve ser imediatamente refletida nos objetos virtuais percebidos pelo usuário. O segundo princípio define que deve haver um alinhamento dos objetos virtuais com os reais, denominado \textit{registro}. Ou seja, o posicionamento dos objetos virtuais deve fazer sentido em relação ao mundo real.

\subsection{Tecnologias para Criar Realidade Aumentada}

Para ser viável, a RA depende de um conjunto de tecnologias para mostrar objetos virtuais e rastrear os objetos reais. A \autoref{subsub_displays} apresenta diferentes categorias de displays e a seção \autoref{subsub_tracking} cita tecnologias de rastreio/registro.

\subsubsection{Displays}
\label{subsub_displays}

Um dos objetivos da RA é produzir integrações de modo que o usuário não consiga distinguir o real do virtual. Diferentes displays têm servido a este propósito. Eles são responsáveis por dispor o objeto virtual em algum ponto entre a retina do observador e o ambiente real. Eles podem estar ou não acoplados ao observador, ser de uso individual ou permitir interações em grupo. Há três classes principais de dispositivos utilizados para mostrar os objetos virtuais: os \textit{head-worn displays}, os \textit{handheld displays} e \textit{projection displays} \cite{azuma_recent_2001}.

\begin{figure}[h]
    \centering
    \includegraphics[width=.9\linewidth,fbox]{figs/ra_displays.png}
    \caption{Interseção de objetos virtuais entre o olho humano e o mundo real. }
    \source{Adaptado de Oliver e Raskar (2015).}
    \label{fig:ra_displays}
\end{figure}

\subsubsubsection*{Head-worn displays}

Os \textit{head-worn displays} (visores de cabeça) são usados na cabeça do usuário e mostram imagens em visores próximos aos olhos. Essa abordagem foi utilizada por Ivan Sutherland na primeira aplicação de RA. Esses visores são comumente de dois tipos. O primeiro tipo é um visor transparente, como uma lente de óculos, que permite ver o mundo real e também mostra os objetos virtuais. O segundo tipo são visores como telas de LCD. Nessa abordagem uma câmera capta o mundo real e transmite ao usuário por meio do visor, que adiciona os objetos virtuais na cena. \citeonline{azuma_recent_2001} cita um terceiro display de cabeça que projeta as imagens diretamente na retina humana usando \textit{lasers} de baixa potência.

\subsubsubsection*{Handheld displays}

Os \textit{handheld displays} (visores de mão) representam o modo mais comum e acessível de RA. É o que \citeonline{milgram_augmented_1994} denomina \textit{window-on-the-world}, ou seja, uma janela no mundo. Os objetos virtuais aparecem em um visor de um dispositivo que o usuário segura com as mãos (um \textit{smartphone} ou \textit{tablet}), que pode ser comparado a uma lupa. Por meio dessa “janela” ou “lupa” o usuário visualiza o mundo real e os objetos virtuais. Por ser o mais comum, há um conjunto de projetos que visam facilitar o desenvolvimento de aplicações de AR para dispositivos móveis, como o ARCore\footnote{\url{https://developers.google.com/ar}}, da Google.

\subsubsubsection*{Projection Displays}

Os \textit{projection displays} (visores de projeção) projetam a informação virtual diretamente sobre o ambiente físico. No caso mais simples, utiliza-se um ou mais projetores fixos no ambiente. Outra estratégia é utilizar projetores acoplados à cabeça do usuário, mas há a desvantagem do peso do equipamento \cite{azuma_recent_2001}. Ambos os casos precisam considerar as características da superfície de projeção, pois superfícies irregulares tendem a deformar a imagem projetada.

A criação de objetos virtuais que aparecem no mesmo espaço físico que os objetos reais se dá no campo da \ac{RAE}. Quando projetores criam os objetos virtuais, \citeonline{resch_enhancing_2016} denomina como \ac{RAEP}, aqui tratada simplesmente como RA Projetiva. Ele cita como vantagens da RA Projetiva:
\begin{itemize}
    \item Não haver erros de profundidade em relação ao ambiente físico, pois os objetos virtuais são projetados diretamente no ambiente;
    \item Ausência de capacetes especiais ou dispositivos que precise segurar com as mãos, aumentando a segurança e liberando ações manuais;
    \item O desacoplamento espacial em relação ao usuário permite que os objetos virtuais sejam acessados por grupos maiores de usuários, o que não ocorre com capacetes ou smartphones;
    \item A resolução obtida com projeção tende a ser maior que a oferecida por dispositivos acoplados à cabeça.
\end{itemize}

Entretanto, há também desvantagens. Ambientes fortemente iluminados podem ofuscar a imagem projetada, o que exige projetores mais potentes ou projetores a \textit{laser}. O segundo problema é a possibilidade de o usuário obstruir a projeção, colocando as mãos entre o projetor e a superfície que recebe a projeção. O uso de múltiplos projetores sincronizados pode mitigar esse problema, porém aumenta custo e dificulta a instalação.

\begin{figure}[h]
    \centering
    \begin{subfigure}{.33\textwidth}
        \centering
        \includegraphics[width=.9\linewidth,fbox]{figs/ivan_sutherland_device.png}
        \caption{Visor de cabeça criado por Ivan Sutherland em 1968.}
        \label{fig_ivan_sutherland}
        \source{\citeonline{sutherland_head-mounted_1968}.}
    \end{subfigure}%
    \begin{subfigure}{.55\textwidth}
        \centering
        \includegraphics[width=.9\linewidth,fbox]{figs/arcore.jpg}
        \caption{Visor de mão, em aplicação para smartphone criada com ARCore.}
        \label{fig_arcore}
    \end{subfigure}%
    \caption{Dispositivos para criar realidade aumentada.}
    \label{fig_ra_devices}
\end{figure}

\subsubsection{Tecnologias de Rastreamento}
\label{subsub_tracking}
O rastreio do usuário, dos objetos virtuais e dos objetos reais, é um aspecto crucial para criar aplicações de RA convincentes \cite{bimber_spatial_2005}. Um conjunto de métodos são utilizados para esse rastreamento, como uso de sensores como giroscópios, acelerômetros e sensores magnéticos, e também captação de imagem \cite{resch_enhancing_2016}. Duas técnicas de rastreamento com captação de imagem são apresentadas a seguir.

\subsubsubsection*{Marcas Fiduciais}

As abordagens de rastreamento com base em captação de imagem precisam extrair características presentes na cena observada. Essas características podem ser naturais ou implantadas artificialmente em pontos de interesse. As marcas fiduciais são exemplos de características artificiais criadas para ser facilmente identificáveis por algoritmos de visão computacional. Essas marcas, apresentadas na \autoref{sub_sec_fiduciais}, além de serem utilizadas em aplicações com interfaces tangíveis, são também aplicadas no campo da RA.

O processo de identificação das marcas artificiais inicia com a captura da imagem. A esta imagem é aplicado um filtro para transformá-la em preto e branco. Segundo \citeonline{resch_enhancing_2016} essa etapa é complexa devido às variações de luminosidade do ambiente. Depois deste filtro, são extraídos os contornos das marcas e por fim o código binário de cores interno à cada marca é decodificado.

No campo da RA projetiva, uma desvantagem do uso de marcas fiduciais é o fato da projeção alterar as características da cena observada, principalmente as cores da marca fiducial, prejudicando sua identificação. Para evitar esse problema é necessário desativar a projeção enquanto a câmera capta as marcas, mas isso impede a projeção em tempo real \cite{resch_enhancing_2016}.

\subsubsubsection*{Características Naturais}
As características naturais são estruturas que pertencem à cena, sem modificações artificiais. Assim como no caso das marcas fiduciais, os algoritmos de visão computacional precisam identificar objetos de interesse em posições e condições luminosas diversas. Para isso procuram basear-se em bordas e pontos.

A identificação de bordas foi um dos primeiros métodos de rastreio de características naturais utilizados, pela facilidade de identificação e robustez em condições variantes de iluminação. Nessa técnica, uma câmera capta um quadro da cena, comparado com um modelo 3D do objeto a ser identificado. Essa comparação tem como saída a estimativa da posição atual do objeto \cite{resch_enhancing_2016}.

Por outro lado, a identificação de pontos é uma alternativa que também é robusta a variações de luminosidade. Pontos de interesse são previamente cadastrados em uma base de dados criada a partir de um modelo 3D observado de diferentes pontos de vista. Os mesmos pontos são, posteriormente, extraídos da imagem captada pela câmera, e comparados aos pontos armazenados. Essa busca permite então encontrar a posição atual aproximada do objeto real.

\subsection{RA Projetiva}
\label{sub_aplicacoes_ra_projetiva}

A RA projetiva é um subtipo da Realidade Aumentada Espacial, a qual normalmente associa um ou mais projetores para produzir o conteúdo virtual e câmeras para captar os objetos reais. \citeonline{bimber_spatial_2005} comentam que os ambientes com uso de projeção se popularizaram na década de 1990. Um exemplo desta época é o CAVE, um quarto cujas paredes serviam de telas para criar uma experiência imersiva. Outros exemplos, com menos imersão, tem projeção em áreas menores, como mesas, paredes, paredes curvadas e esferas.

A RA projetiva tem encontrado aplicações em áreas diversas. Uma das abordagens é simular a visualização de estruturas internas a uma superfície, para facilitar o manuseio das mesmas sem a necessidade de abrir a superfície. Exemplos são órgãos humanos, no campo da medicina, e peças de veículos, na mecânica. Em um trabalho neste sentido, \citeonline{bornemann_exploration_2020} combinam três projetores apontados para um manequim e projetam os órgãos humanos permitindo estudar sua localização (\autoref{fig_bornemann}). Essa projeção se modifica conforme os movimentos da cabeça do observador, dando às estruturas projetadas um aspecto tridimensional. Essa técnica potencialmente facilitaria cirurgias não invasivas, nas quais atualmente o cirurgião divide a atenção entre o corpo do paciente e um monitor. A projeção dos órgãos sobre o corpo do paciente evitaria a divisão de atenção, mantendo os olhos direcionados para um único local.

Outra aplicação na área médica é o tratamento de pacientes com fobias de pequenos animais. \citeonline{wrzesien_treating_2015} usam um projetor para mostrar os animais que o paciente teme e ele pode interagir com os mesmos de forma controlada (\autoref{fig_wrzesien}). No campo da indústria, \citeonline{sand_smartassembly_2016} desenvolveram o smARt.assembly, um sistema de assistência a trabalhadores responsáveis por montagens manuais. O sistema tem um projetor apontado para uma estante com peças, onde destaca a próxima peça a ser utilizada e também mostra como encaixá-la no produto a ser montado (\autoref{fig_sand}).

\begin{figure}
    \centering
    \begin{subfigure}{.33\textwidth}
        \centering
        \includegraphics[width=.9\linewidth,fbox]{figs/bornemann.png}
        \caption{Projeção de órgãos internos.}
        \label{fig_bornemann}
        \source{\citeonline{bornemann_exploration_2020}.}
    \end{subfigure}%
    \begin{subfigure}{.33\textwidth}
        \centering
        \includegraphics[width=.9\linewidth,fbox]{figs/wrzesien.png}
        \caption{Tratamento de fobias.}
        \label{fig_wrzesien}
        \source{\citeonline{wrzesien_treating_2015}.}
    \end{subfigure}%
    \begin{subfigure}{.33\textwidth}
        \centering
        \includegraphics[width=.9\linewidth,fbox]{figs/sand.png}
        \caption{Auxílio em linhas de montagem.}
        \label{fig_sand}
        \source{\citeonline{sand_smartassembly_2016}.}
    \end{subfigure}%
    \caption{Aplicações de RA Projetiva.}
    \label{fig_proj_ra_applications}
\end{figure}

\subsubsection{RA Projetiva Aplicada a Ferramentas Educacionais}
\label{sub_sub_aplicacoes_ra_projetiva_educacao}

A \ac{RA} tem potencial educacional ao motivar os estudantes e promover a interação entre o conteúdo e o aluno \cite{silva_evaluating_2013}. Portanto, além das aplicações na medicina e na indústria, a RA projetiva também se aplica a ferramentas educacionais. Além da RA projetiva, essas ferramentas normalmente utilizam elementos tangíveis que servem como entradas para sistemas câmera-projetor. Câmeras captam os elementos tangíveis e algoritmos de visão computacional identificam esses elementos analisando suas marcas especiais ou suas características naturais. Como saída, um projetor emite os elementos virtuais.

A união entre RA projetiva e interfaces tangíveis em aplicações educacionais favorece interações sociais, o que favorece o aprendizado por meio do \textit{scaffolding} (\autoref{sub_jerome_bruner}). A combinação \textit{RA projetiva-interfaces tangíveis} favorece as interações em grupo de dois modos. Primeiro, a RA projetiva mostra os objetos virtuais a mais de um usuário simultaneamente. Segundo, as interfaces tangíveis permitem a manipulação de objetos físicos por mais de um usuário \cite{burleson_active_2018, horn_tangible_2012}.

\begin{figure}[h]
    \centering
    \begin{subfigure}{.49\textwidth}
        \includegraphics[width=.9\linewidth,fbox]{figs/nectar.png}
        \caption{Nectar - Exploração de modos de cores.}
        \label{fig_nectar}
        \source{\citeonline{laviole_nectar_2018}.}
    \end{subfigure}
    \begin{subfigure}{.49\textwidth}
        \includegraphics[width=.9\linewidth,fbox]{figs/pinkaew.png}
        \caption{Tangible Word Game - Alfabetização.}
        \source{\citeonline{pinkaew_interactive_2014}.}
        \label{fig_pinkaew}
    \end{subfigure}
    \begin{subfigure}{.49\textwidth}
        \includegraphics[width=.9\linewidth,fbox]{figs/roberto.png}
        \caption{ARBlocks - Atividade de alfabetização.}
        \label{fig_silva_roberto_ra}
        \source{\citeonline{silva_evaluating_2013}.}
    \end{subfigure}
    \begin{subfigure}{.49\textwidth}
        \includegraphics[width=.9\linewidth,fbox]{figs/mart.png}
        \caption{MaR-T - Atividade de matemática.}
        \label{fig_math}
        \source{\citeonline{besevli_mar_t_2019}.}
    \end{subfigure}
    \caption{Ferramentas educacionais usando RA projetiva.}
\end{figure}

\citeonline{laviole_nectar_2018} apresenta uma ferramenta para exploração de modelos de cores aditivas e subtrativas (\autoref{fig_nectar}). A soma das cores primárias no modo aditivo (verde, vermelho e azul) resulta em branco, e a soma das cores primárias no modo subtrativo (ciano, magenta e amarelo) resulta em preto. Na ferramenta de Laviole, cartas com marcas fiduciais representam as cores, e ao lado de cada carta é projetado um círculo colorido que pode ser sobreposto a outros círculos. Além disso, há uma carta que permite trocar entre o modo aditivo e o subtrativo. Um questionário guia os estudantes na exploração das cartas, com perguntas como: o que é “a cor branca”? O que você vê ao combinar vermelho, verde e azul? Tentando responder às perguntas, os estudantes exploram as combinações de modo ativo e colaborativo, possivelmente compreendendo esse fenômeno físico complexo.

Outras duas ferramentas visam promover a alfabetização. \citeonline{pinkaew_interactive_2014} identificam sequências de letras de plástico e projetam figuras referentes às palavras formadas. Uma câmera de infravermelho capta as letras, técnica que apresentou problemas de diferenciação de letras similares como Q, O, e C, devido a fontes de luz inadequadas. A segunda ferramenta é o ARBlocks, desenvolvido por \citeonline{roberto_dynamic_2013}. O ARBlocks possui blocos tangíveis customizáveis via projeção de conteúdo virtual, bem como feedbacks luminosos e sonoros. A atividade proposta consistiu na formação de rimas ao completar frases com blocos tangíveis (\autoref{fig_silva_roberto_ra}). A avaliação com grupo de teste e de controle concluiu que o grupo de teste, com dificuldade de aprendizado, conseguiu aprender de modo similar ao nos assuntos abordados usando RA. A professora da turma também mencionou motivação e engajamento das crianças no uso da ferramenta, a qual afirma tê-las incentivado a lerem mais.

Por fim, a MaR-T é uma ferramenta para auxiliar crianças de 3 a 5 anos no desenvolvimento da representação numérica não-simbólica, ou seja, a comparação entre grandezas (tamanhos, quantidades) antes do reconhecimento dos símbolos numéricos. Desenvolvida por \citeonline{besevli_mar_t_2019},mostra uma sequência de atividades nas quais a criança agrupa pequenas pedras de modo a permitir a passagem de um personagem virtual sobre buracos e rios. As pedras são dispostas vertical ou horizontalmente, ou ainda agrupadas para a criança compreender a conservação de quantidades em diferentes disposições. Em cada etapa, a criança coloca a mão sobre o grupo que possui maior ou menor quantidade de pedras. A aplicação utiliza um projetor acoplado a um \textit{smartphone} Android, e as peças utilizam adesivos refletores que facilitam a identificação por meio da biblioteca OpenCV.

\subsubsection{Métodos de Entrada}
Os métodos de entrada desses sistemas são diversos. No caso do smaArt.assembly o trabalhador controla o sistema usando pedais, para não perder tempo de trabalho manual. Já o sistema de \citeonline{bornemann_exploration_2020} combina a captação de movimentos da cabeça do usuário através de controles remotos que tem sua posição rastreada por sistemas específicos. Ambos os trabalhos citam o reconhecimento de gestos como um método de entrada alternativo a ser testado futuramente. Já o trabalho de \citeonline{wrzesien_treating_2015} reconhece gestos captados por uma câmera, de modo que o paciente pode interagir com os animais projetados colocando a mão sobre eles. Métodos de entrada tradicionais também são aplicados. Plecher et al (2020) usam RA projetiva em uma exposição de museu, onde os usuários interagem usando \textit{tablet} para pintar uma estátua em exposição, de modo que as cores selecionadas no aparelho são projetadas na escultura. Por fim, as ferramentas educacionais apresentadas (\autoref{sub_sub_aplicacoes_ra_projetiva_educacao}) tem em comum o uso de interfaces tangíveis com ou sem marcas fiduciais, identificadas por câmeras.

\section{Considerações}

Este capítulo abordou fundamentos para guiar a criação de interfaces de programação para crianças. Olhar para o indivíduo que usará uma ferramenta, pensando no seu desenvolvimento cognitivo, limitações motoras e aspectos emocionais é a direção apontada por Montessori, Piaget, Bruner e Papert.

A segunda seção (\autoref{fundamentacao_pc}) abordou a definição de \acl{PC}. Apesar da falta de uma definição estabelecida, percebe-se que há relação com programação, mas que também vai além desta. Os pilares de decomposição, reconhecimento de padrões e abstração podem ser aplicados em resolução de problemas por vezes sem o uso de dispositivos computacionais. A depuração, por estar associada à tarefa de programar, por vezes tem importância secundária e não é mencionada em definições do PC.

A seguir foram abordadas duas classificações de brinquedos programáveis e diferentes alternativas tecnológicas empregadas em suas interfaces. Percebe-se o incentivo ao uso de interfaces tangíveis para crianças, e que a programação em blocos é a metáfora mais utilizada para representar comandos. A preocupação com o design dos blocos também é aparente, por exemplo, ao evitar usar letras em blocos destinados a crianças não alfabetizadas.

Um último item abordado foram novas formas de interação: interfaces de realidade virtual, aumentada e mista. Como demonstrado no próximo capítulo, poucos brinquedos programáveis utilizam interfaces de \ac{RA}. Por isso, investigar a adequação dessas tecnologias para o público infantil é um tema a ser explorado.